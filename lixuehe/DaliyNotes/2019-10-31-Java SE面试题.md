# Java SE面试题

1：重载与重写有什么区别？

```
override（重写）

　　 1.方法名、参数、返回值类型相同。
　　 2.子类方法不能缩小父类方法的访问权限。
　　 3.子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。
　　 4.存在于父类和子类之间。
　　 5.方法被定义为final不能被重写。

　overload（重载）

　　1.参数类型、个数、顺序至少有一个不相同。 
　　2.不能重载只有返回值不同的方法名。
　　3.存在于父类和子类、同类中。
```

2：&和&&有什么区别？

```
&按位与----a&b是把a和b都转换成二进制数然后再进行与的运算
            不管前面的条件是否正确，后面都执行
&&逻辑与---a&&b就是当且仅当两个操作数均为 true时，其结果才为 true；（短路功能）
        前面条件正确时，才执行后面，不正确时，就不执行，效率高
```

3：HashTable和HashMap有什么区别？

```
- HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口
- 主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高Hashtable
- HashMap允许将null作为一个entry的key或者value，而Hashtable不允许
- 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是
```

4：用最有效率的方法算出2乘以8等于多少？

```
2 << 3
```

5：final, finally, finalize的区别？

```
final—修饰符（关键字）
    如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。
    一个类不能既被声明为 abstract的，又被声明为final的
    被声明为final的方法也同样只能使用，不能重写

finally—异常处理时提供 finally 块来执行操作
    finally块则是无论异常是否发生，都会执行finally块的内容

finalize—方法名
    finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的
    它是在object类中定义的，所有的类都继承了它
```

6：字节流和字符流有什么区别？

```
字节流：按字节读写
字符流：按字符

通常在处理文本时优先使用字符流，其他的用字节流
字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件
```

7：Arraylist和Linkedlist的区别?

```
ArrayList、LinkedList、Vector和Stack是List的四个实现类，其中Vector是基于JDK1.0，虽然实现了同步，但是效率低，已经不用了，Stack继承Vector

区别：

    - ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构
    - 对于随机访问get和set，ArrayList要优于LinkedList，LinkedList不支持高效的随机访问
    - ArrayList适合查找，LinkedList适合增删
```

8：接口和抽象类有什么区别？

```
抽象类（abstract class）：
    1：abstract 关键字修饰，并且没有方法体
    2：抽象类不能直接创建实例
    3：抽象类只能被继承，一个具体类继承一个抽象类，必须实现所有抽象方法


接口（interface）：
    1：实现接口的一定要实现接口里定义的所有方法
    2：接口可以实现多重继承

区别：
    1：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用
    2：一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类
    3：接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法
    4：抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的
    5：抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法
```

9：String， StringBuffer， StringBuilder 的区别？

```
- 运行速度快慢为：StringBuilder > StringBuffer > String
    - （String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的）
- StringBuilder是线程不安全的，而String、StringBuffer是线程安全的
```

10：TCP和UDP的区别？哪个是三次握手协议？

```
TCP稳定性较高，但效率低
UDP通讯相反，效率较高，但稳定性较差
```

11：创建多线程的方式分别是什么？线程死锁是如何产生的？如何防止线程死锁现象？

```
方式：
    继承Thread、实现 Runnable 接口

产生:

    - 一个资源每次只能被一个进程使用
    - 一个进程因请求发生阻塞时，依然对已获得的资源保持不放
    - 进程已经获得资源使用权，但是一直未使用
    - 同一个进程，频繁的获取资源的优先使用权，一直未释放

防止：
    加锁顺序（线程按照一定的顺序加锁）
    加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）
    死锁检测（一般是将所有的锁存放于map对象中，检测map中的锁）
```

12：一个汉字几个字节，一个char类型的变量，能储存一个汉字吗，为什么？

```
两个字节，可以存储，前提是汉字必须是Unicode编码
```

13：多线程中run和start方法有什么区别？

```
Thread的start才是正在开启线程
Run只是调用了一个普通方法，并没有启动另一个线程，程序还是会按照顺序执行相应的代码
Start则表示，重新开启一个线程，不必等待其他线程运行完，只要得到cup就可以运行该线程
```

14：静态变量和实例变量有什么区别？

```
静态变量前面要加static，实例变量不用
实例变量属于对象的属性，必须创建了实例对象，才可以被使用，静态变量不属于某个实例对象，而是属于类，也叫类变量，不用创建任何实例对象就会被使用
```

15：List和Map有什么区别？

```
list：
    - 链表
    - 有序
    - 继承Collection(set也是)
    - 可以有重复的对象值，但是对象下标不能重复
Map：
    - key-value
    - 无序
    - 键不能有重复的 值可以重复
```

16：==与equals有什么区别？

```
==：比较两个数据内存地址是否相同
equals：比较两个数据值是否一样  
```

17：++i与i++的区别？

```
++i：先赋值+1，后使用i进行其它运算
i++：先使用i进行其它运算，后赋值+1
```

18：Integer与int的区别？

```
int 是基本数据类型，初值为0
Integer是int的包装类，初值为null

Integer缓存：注意拆箱和装箱（-128-127之间）

原始类型：boolean，char，byte，short，int，long，float，double
包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double
```

19：如果equals方法比较为true，那么它们的Hashcode值一定相同吗？ 如果hashcode相同，那么equals方法比较一定为true吗？

```
不一定相同
一定

重写equals方法时请必须重写hashcode，以保证equals方法相等时两个对象hashcode返回相同的值

总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。 前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。
那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。 也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。  
于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。 哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上
```

20：Java 中的final关键字有哪些用法？

```
1：修饰类：表示该类不能被继承
2：修饰方法：表示方法不能被重写
3：修饰变量：表示变量只能一次赋值以后值不能被修改（常量）
```

21：Error和Exception有什么区别？什么时候需要捕获异常，什么时候需要抛出异常？

```
1:Error表示系统级的错误和程序不必处理的异常,有可能恢复，但是恢复比较困难的严重问题。
2：Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况

异常处理的原则：
    1：System.out.println是高代价的。调用System.out.println会降低系统吞吐量
    2：在生产环境中别用异常的printStackTrace()方法。
    3：如果你不能处理异常，不要捕获该异常
    4：如果要捕获，应在离异常源近的地方捕获它
    5：捕获的异常一定要做处理
    6：可以自定义异常
    7：就近原则
```

22：下面程序的运行结果是()？

```
String str1 = "hello";
String str2 = "he" + new String("llo");
System.err.println(str1 == str2);

false
```

23：进程和线程的区别是什么？

```
- 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元
- 同一个进程中可以包括多个线程
- 进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束
- 线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程
- 进程的创建调用fork或者vfork，而线程的创建调用pthread_create
- 线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源
```

24：进程的几种状态分别是什么？

```
就绪状态：

    当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态

运行状态：

    当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为运行状态

阻塞状态：

    正在运行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等


状态转换：

    就绪→运行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成运行状态

    运行→就绪：处于运行状态的进程在其运行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从运行状态转变成就绪状态

    运行→阻塞：正在运行的进程因等待某种事件发生而无法继续运行时，便从运行状态变成阻塞状态

    阻塞→就绪：处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态
```

25：请说出你所知道的线程同步的方法？

```
wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 
notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。
```

26：Java支持的数据类型有哪些？什么是自动拆装箱？

```
8种基本数据类型：

    byte      8位         取值范围  -2^7 ~ 2^7 -1

    short     16位        取值范围  -2^15 ~ 2^15 - 1

    char      16位        取值范围  0 ~ 2 ^16 - 1

    boolean   位数不明确   取值范围  true false

    int       32位        取值范围  -2^31 ~ 2^31 - 1

    long      64位        取值范围  -2^63 ~ 2^ 63 - 1

    float     32位        取值范围  1.4e-45 ~ 3.40e38

    double    64位        取值范围  4.9e-324 ~ 1.79e308


注意：

    需要注意的是，String不是基本数据类型，而是引用类型


在jdk1.5中引入了自动拆装箱的新特性，自动拆装箱，是指基本数据类型和引用数据类型之间的自动转换

    基本类型转换成包装类型，称为装箱  

    Integer intObjct = new Integer(2); //装箱 
    //Integer intObjct = 2 //自动装箱  
    //自动装箱，如果一个基本类型值出现在需要对象的环境中，会自动装箱  

    如Integer 和 int 可以自动转换； Float和float可以自动转换
```

27：构造器（constructor）是否可被重写（override）?是否可被重载？是否可被继承？

```
构造器不能被继承，因此不能重写Override，但可以被重载Overload。
```

28：写出冒泡排序的程序代码？(要求高逼格的代码)

```
接口：

import java.util.Comparator;

/**
 * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换)
 */
public interface Sorter {

   /**
    * 排序
    * @param list 待排序的数组
    */
   public <T extends Comparable<T>> void sort(T[] list);

   /**
    * 排序
    * @param list 待排序的数组
    * @param comp 比较两个对象的比较器
    */
   public <T> void sort(T[] list, Comparator<T> comp);
}



实现类：

import java.util.Comparator;

/**
 * 冒泡排序
 *
 */
public class BubbleSorter implements Sorter {

    @Override
    public <T extends Comparable<T>> void sort(T[] list) {
        boolean swapped = true;
        for (int i = 1, len = list.length; i < len && swapped; ++i) {
            swapped = false;
            for (int j = 0; j < len - i; ++j) {
                if (list[j].compareTo(list[j + 1]) > 0) {
                    T temp = list[j];
                    list[j] = list[j + 1];
                    list[j + 1] = temp;
                    swapped = true;
                }
            }
        }
    }

    @Override
    public <T> void sort(T[] list, Comparator<T> comp) {
        boolean swapped = true;
        for (int i = 1, len = list.length; i < len && swapped; ++i) {
            swapped = false;
            for (int j = 0; j < len - i; ++j) {
                if (comp.compare(list[j], list[j + 1]) > 0) {
                    T temp = list[j];
                    list[j] = list[j + 1];
                    list[j + 1] = temp;
                    swapped = true;
                }
            }
        }
    }
}
```

29：简述单例模式的特征和应用场景，单例模式示例代码？

```
单例模式（Singleton），也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。
单例模式只允许创建一个对象，因此节省内存，加快对象访问速度

单例模式要素： 
    a.私有构造方法 
    b.私有静态引用指向自己实例 
    c.以自己实例为返回值的公有静态方法 

饿汉式：单例实例在类装载时就构建，急切初始化。（预先加载法） 

    优点 
        1.线程安全 
        2.在类加载的同时已经创建好一个静态对象，调用时反应速度快 
    缺点 
         资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化 

懒汉式：单例实例在第一次被使用时构建，延迟初始化。 

应用场景：

    - 需要频繁实例化然后销毁的对象
    - 创建对象时耗时过多或者耗资源过多，但又经常用到的对象
    - 有状态的工具类对象
    - 频繁访问数据库或文件的对象
    - 网站计数器，一般是采用单例模式实现
    - 由于配置文件一般都是共享资源，即web应用的配置对象的读取，一般采用单例模式来实现。如：spring的配置文件的读取等
    - 多线程的线程池的设计一般也是采用单例模式
    - 数据库连接池的设计

饿汉式单例：
    public class Singleton {
        private Singleton(){}
        private static Singleton instance = new Singleton();
        public static Singleton getInstance(){
            return instance;
        }
    }


懒汉式单例：
    public class Singleton {
        private static Singleton instance = null;
        private Singleton() {}
        public static synchronized Singleton getInstance(){
            if (instance == null) 
                instance ＝ new Singleton();
            return instance;
        }
    }


实现一个单例有两点注意事项：
    - 将构造器私有，不允许外界通过构造器创建对象
    - 通过公开的静态方法向外界返回类的唯一实例
```

30：什么是java序列化，如何实现java序列化？

```
概念：
    序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化（将对象转换成二进制）。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题

序列化：把Java对象转换为字节序列的过程。
反序列化：把字节序列恢复为Java对象的过程。

实现：

    将需要被序列化的类实现Serializable接口

注意：

    被关键字static、transient修饰的变量不能被序列化。在被序列化后，transient修饰的变量会被设为初始值。如int型的是0、对象型的是null.
```

31：在JAVA中，如何跳出当前的多重嵌套循环？

```
用break; return 方法
```

32：面向对象的特征有哪些方面？

```
- 抽象：
    抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。
- 继承：
    继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
- 封装：
    封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。
- 多态性：
    多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
```

33：Collection 和 Collections的区别？

```
Collection是集合类的上级接口
    继承与他的接口主要有Set 和List. 
Collections是针对集合类的一个帮助类
    他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。
```